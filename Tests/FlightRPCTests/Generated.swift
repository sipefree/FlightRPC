// Generated using Sourcery 0.17.0 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT



extension TestProtocols {
        struct clientMethodAbingIntbangStringcompletionescapingFloatVoid: Codable {
    
    }
        struct clientMethodBboomDouble: Codable {
    
    }
    }
extension TestProtocols {
        struct serverMethodAfooStringbarIntcompletionescapingIntVoid: Codable {
    
    }
        struct serverMethodBbazInt: Codable {
    
    }
    }
/*
Protocols:
    ClientProtocol : Protocol: module = nil, typealiases = ["Suite": Typealias: aliasName = Suite, typeName = TestProtocols, parentName = Optional("ClientProtocol"), name = ClientProtocol.Suite], isExtension = false, kind = protocol, accessLevel = internal, name = ClientProtocol, isGeneric = false, localName = ClientProtocol, variables = [], methods = [Method: name = clientMethodA(        bing: Int,        bang: String,        completion: @escaping (Float) -> Void    ), selectorName = clientMethodA(bing:bang:completion:), parameters = [MethodParameter: argumentLabel = Optional("bing"), name = bing, typeName = Int, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("bang"), name = bang, typeName = String, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("completion"), name = completion, typeName = @escaping (Float) -> Void, `inout` = false, typeAttributes = ["escaping": @escaping], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ClientProtocol), attributes = [:], Method: name = clientMethodB(        boom: Double    ), selectorName = clientMethodB(boom:), parameters = [MethodParameter: argumentLabel = Optional("boom"), name = boom, typeName = Double, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ClientProtocol), attributes = [:]], subscripts = [], initializers = [], annotations = [:], staticVariables = [], staticMethods = [], classMethods = [], instanceVariables = [], instanceMethods = [Method: name = clientMethodA(        bing: Int,        bang: String,        completion: @escaping (Float) -> Void    ), selectorName = clientMethodA(bing:bang:completion:), parameters = [MethodParameter: argumentLabel = Optional("bing"), name = bing, typeName = Int, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("bang"), name = bang, typeName = String, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("completion"), name = completion, typeName = @escaping (Float) -> Void, `inout` = false, typeAttributes = ["escaping": @escaping], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ClientProtocol), attributes = [:], Method: name = clientMethodB(        boom: Double    ), selectorName = clientMethodB(boom:), parameters = [MethodParameter: argumentLabel = Optional("boom"), name = boom, typeName = Double, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ClientProtocol), attributes = [:]], computedVariables = [], storedVariables = [], inheritedTypes = ["FlightProtocol"], containedTypes = [], parentName = nil, parentTypes = AnyIterator<Type>(_box: Swift._IteratorBox<Swift._ClosureBasedIterator<SourceryRuntime.Type>>), attributes = [:], kind = protocol

    ServerProtocol : Protocol: module = nil, typealiases = ["Suite": Typealias: aliasName = Suite, typeName = TestProtocols, parentName = Optional("ServerProtocol"), name = ServerProtocol.Suite], isExtension = false, kind = protocol, accessLevel = internal, name = ServerProtocol, isGeneric = false, localName = ServerProtocol, variables = [], methods = [Method: name = serverMethodA(        foo: String,        bar: Int,        completion: @escaping (Int) -> Void    ), selectorName = serverMethodA(foo:bar:completion:), parameters = [MethodParameter: argumentLabel = Optional("foo"), name = foo, typeName = String, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("bar"), name = bar, typeName = Int, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("completion"), name = completion, typeName = @escaping (Int) -> Void, `inout` = false, typeAttributes = ["escaping": @escaping], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ServerProtocol), attributes = [:], Method: name = serverMethodB(        baz: Int    ), selectorName = serverMethodB(baz:), parameters = [MethodParameter: argumentLabel = Optional("baz"), name = baz, typeName = Int, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ServerProtocol), attributes = [:]], subscripts = [], initializers = [], annotations = [:], staticVariables = [], staticMethods = [], classMethods = [], instanceVariables = [], instanceMethods = [Method: name = serverMethodA(        foo: String,        bar: Int,        completion: @escaping (Int) -> Void    ), selectorName = serverMethodA(foo:bar:completion:), parameters = [MethodParameter: argumentLabel = Optional("foo"), name = foo, typeName = String, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("bar"), name = bar, typeName = Int, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:], MethodParameter: argumentLabel = Optional("completion"), name = completion, typeName = @escaping (Int) -> Void, `inout` = false, typeAttributes = ["escaping": @escaping], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ServerProtocol), attributes = [:], Method: name = serverMethodB(        baz: Int    ), selectorName = serverMethodB(baz:), parameters = [MethodParameter: argumentLabel = Optional("baz"), name = baz, typeName = Int, `inout` = false, typeAttributes = [:], defaultValue = nil, annotations = [:]], returnTypeName = Void, `throws` = false, `rethrows` = false, accessLevel = internal, isStatic = false, isClass = false, isFailableInitializer = false, annotations = [:], definedInTypeName = Optional(ServerProtocol), attributes = [:]], computedVariables = [], storedVariables = [], inheritedTypes = ["FlightProtocol"], containedTypes = [], parentName = nil, parentTypes = AnyIterator<Type>(_box: Swift._IteratorBox<Swift._ClosureBasedIterator<SourceryRuntime.Type>>), attributes = [:], kind = protocol


*/
